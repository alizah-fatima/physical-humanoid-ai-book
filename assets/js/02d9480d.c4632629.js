"use strict";(globalThis.webpackChunkphysical_humanoid_ai_book=globalThis.webpackChunkphysical_humanoid_ai_book||[]).push([[864],{6113(n,e,i){i.r(e),i.d(e,{assets:()=>a,contentTitle:()=>l,default:()=>u,frontMatter:()=>t,metadata:()=>o,toc:()=>c});const o=JSON.parse('{"id":"module2-digital-twin/chapter1-gazebo-intro","title":"Chapter 1: Introduction to Gazebo - Physics Simulation for Humanoid Robotics","description":"Learning Objectives","source":"@site/docs/module2-digital-twin/chapter1-gazebo-intro.md","sourceDirName":"module2-digital-twin","slug":"/module2-digital-twin/chapter1-gazebo-intro","permalink":"/docs/module2-digital-twin/chapter1-gazebo-intro","draft":false,"unlisted":false,"editUrl":"https://github.com/alizah-fatima/physical-humanoid-ai-book/tree/main/docs/module2-digital-twin/chapter1-gazebo-intro.md","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"sidebar_position":1},"sidebar":"tutorialSidebar","previous":{"title":"Chapter 3: URDF for Humanoid Robot Description and Modeling","permalink":"/docs/module1-ros2/chapter3-urdf-modeling"},"next":{"title":"Chapter 2: Robot Description Formats - URDF and SDF for Humanoid Modeling","permalink":"/docs/module2-digital-twin/chapter2-urdf-sdf-modeling"}}');var s=i(4848),r=i(8453);const t={sidebar_position:1},l="Chapter 1: Introduction to Gazebo - Physics Simulation for Humanoid Robotics",a={},c=[{value:"Learning Objectives",id:"learning-objectives",level:2},{value:"Introduction to Gazebo",id:"introduction-to-gazebo",level:2},{value:"Installing and Setting Up Gazebo",id:"installing-and-setting-up-gazebo",level:2},{value:"System Requirements",id:"system-requirements",level:3},{value:"Installation",id:"installation",level:3},{value:"Basic Gazebo Launch",id:"basic-gazebo-launch",level:3},{value:"Physics Simulation Fundamentals",id:"physics-simulation-fundamentals",level:2},{value:"Physics Engines",id:"physics-engines",level:3},{value:"Configuring Physics Properties",id:"configuring-physics-properties",level:3},{value:"Gravity Configuration",id:"gravity-configuration",level:3},{value:"Time Step Configuration",id:"time-step-configuration",level:3},{value:"Collision Detection and Dynamics",id:"collision-detection-and-dynamics",level:2},{value:"Collision Properties",id:"collision-properties",level:3},{value:"Material Properties for Humanoid Simulation",id:"material-properties-for-humanoid-simulation",level:3},{value:"Building Custom Simulation Environments",id:"building-custom-simulation-environments",level:2},{value:"Using Gazebo&#39;s Building Editor",id:"using-gazebos-building-editor",level:3},{value:"Creating Custom World Files",id:"creating-custom-world-files",level:3},{value:"Environment Elements for Humanoid Training",id:"environment-elements-for-humanoid-training",level:3},{value:"Flat Ground Area",id:"flat-ground-area",level:4},{value:"Obstacle Course",id:"obstacle-course",level:4},{value:"Gazebo-ROS 2 Integration",id:"gazebo-ros-2-integration",level:2},{value:"Launching Gazebo with ROS 2",id:"launching-gazebo-with-ros-2",level:3},{value:"Spawning Robots in Gazebo",id:"spawning-robots-in-gazebo",level:3},{value:"Performance Optimization for Humanoid Simulation",id:"performance-optimization-for-humanoid-simulation",level:2},{value:"Reducing Computational Load",id:"reducing-computational-load",level:3},{value:"Visual Optimization",id:"visual-optimization",level:3},{value:"Troubleshooting Common Issues",id:"troubleshooting-common-issues",level:2},{value:"Robot Falling Through Ground",id:"robot-falling-through-ground",level:3},{value:"Unstable Simulation",id:"unstable-simulation",level:3},{value:"Performance Issues",id:"performance-issues",level:3},{value:"Summary",id:"summary",level:2}];function d(n){const e={code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...n.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(e.header,{children:(0,s.jsx)(e.h1,{id:"chapter-1-introduction-to-gazebo---physics-simulation-for-humanoid-robotics",children:"Chapter 1: Introduction to Gazebo - Physics Simulation for Humanoid Robotics"})}),"\n",(0,s.jsx)(e.h2,{id:"learning-objectives",children:"Learning Objectives"}),"\n",(0,s.jsx)(e.p,{children:"By the end of this chapter, you will be able to:"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Understand the fundamentals of Gazebo simulation environment"}),"\n",(0,s.jsx)(e.li,{children:"Set up Gazebo for humanoid robotics simulation"}),"\n",(0,s.jsx)(e.li,{children:"Configure physics properties including gravity and collision detection"}),"\n",(0,s.jsx)(e.li,{children:"Build custom simulation environments for humanoid robots"}),"\n",(0,s.jsx)(e.li,{children:"Integrate Gazebo with ROS 2 for realistic robot simulation"}),"\n"]}),"\n",(0,s.jsx)(e.h2,{id:"introduction-to-gazebo",children:"Introduction to Gazebo"}),"\n",(0,s.jsx)(e.p,{children:"Gazebo is a powerful open-source 3D robotics simulator that provides realistic physics simulation, high-quality graphics, and convenient programmatic interfaces. It's widely used in robotics research and development for testing algorithms, robot design, and training AI agents in a safe virtual environment before deployment on real robots."}),"\n",(0,s.jsx)(e.p,{children:"For humanoid robotics, Gazebo offers:"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Accurate physics simulation with multiple physics engines (ODE, Bullet, Simbody)"}),"\n",(0,s.jsx)(e.li,{children:"Realistic sensor simulation (cameras, LiDAR, IMUs, force/torque sensors)"}),"\n",(0,s.jsx)(e.li,{children:"Flexible environment modeling with building editor"}),"\n",(0,s.jsx)(e.li,{children:"Integration with ROS/ROS 2 through gazebo_ros packages"}),"\n",(0,s.jsx)(e.li,{children:"Support for complex humanoid models with multiple degrees of freedom"}),"\n"]}),"\n",(0,s.jsx)(e.h2,{id:"installing-and-setting-up-gazebo",children:"Installing and Setting Up Gazebo"}),"\n",(0,s.jsx)(e.h3,{id:"system-requirements",children:"System Requirements"}),"\n",(0,s.jsx)(e.p,{children:"Before installing Gazebo, ensure your system meets the requirements:"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Ubuntu 20.04/22.04 or newer (recommended for ROS 2 compatibility)"}),"\n",(0,s.jsx)(e.li,{children:"Graphics card with OpenGL 2.1+ support"}),"\n",(0,s.jsx)(e.li,{children:"Minimum 4GB RAM (8GB+ recommended for complex humanoid simulations)"}),"\n",(0,s.jsx)(e.li,{children:"Multi-core processor for optimal performance"}),"\n"]}),"\n",(0,s.jsx)(e.h3,{id:"installation",children:"Installation"}),"\n",(0,s.jsx)(e.p,{children:"For ROS 2 Humble Hawksbill (Ubuntu 22.04):"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-bash",children:"sudo apt update\nsudo apt install gazebo libgazebo-dev\n# For ROS 2 integration\nsudo apt install ros-humble-gazebo-ros ros-humble-gazebo-plugins ros-humble-gazebo-dev\n"})}),"\n",(0,s.jsx)(e.h3,{id:"basic-gazebo-launch",children:"Basic Gazebo Launch"}),"\n",(0,s.jsx)(e.p,{children:"To launch Gazebo with an empty world:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-bash",children:"gz sim\n# Or for older versions\ngazebo\n"})}),"\n",(0,s.jsx)(e.h2,{id:"physics-simulation-fundamentals",children:"Physics Simulation Fundamentals"}),"\n",(0,s.jsx)(e.h3,{id:"physics-engines",children:"Physics Engines"}),"\n",(0,s.jsx)(e.p,{children:"Gazebo supports multiple physics engines, each with different characteristics:"}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"ODE (Open Dynamics Engine)"}),": Default engine, good balance of speed and accuracy"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Bullet"}),": Good for complex collision detection and articulated bodies"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Simbody"}),": High accuracy for biomechanics and complex articulated systems"]}),"\n"]}),"\n",(0,s.jsx)(e.h3,{id:"configuring-physics-properties",children:"Configuring Physics Properties"}),"\n",(0,s.jsx)(e.p,{children:"The physics properties are defined in the world file (SDF format):"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-xml",children:'<sdf version="1.7">\n  <world name="default">\n    \x3c!-- Physics engine configuration --\x3e\n    <physics type="ode">\n      <max_step_size>0.001</max_step_size>\n      <real_time_factor>1.0</real_time_factor>\n      <real_time_update_rate>1000.0</real_time_update_rate>\n      <gravity>0 0 -9.8</gravity>\n    </physics>\n\n    \x3c!-- Environment content --\x3e\n    <include>\n      <uri>model://ground_plane</uri>\n    </include>\n    <include>\n      <uri>model://sun</uri>\n    </include>\n  </world>\n</sdf>\n'})}),"\n",(0,s.jsx)(e.h3,{id:"gravity-configuration",children:"Gravity Configuration"}),"\n",(0,s.jsx)(e.p,{children:"Gravity is a crucial parameter for humanoid simulation. The default value is -9.8 m/s\xb2 on the Z-axis:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-xml",children:"<gravity>0 0 -9.8</gravity>\n"})}),"\n",(0,s.jsx)(e.p,{children:"For humanoid robots, you might want to adjust:"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Gravity strength for different planetary environments"}),"\n",(0,s.jsx)(e.li,{children:"Direction for testing non-standard scenarios"}),"\n",(0,s.jsx)(e.li,{children:"Temporarily disable for specific testing purposes"}),"\n"]}),"\n",(0,s.jsx)(e.h3,{id:"time-step-configuration",children:"Time Step Configuration"}),"\n",(0,s.jsx)(e.p,{children:"The physics simulation accuracy depends on the time step settings:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-xml",children:"<max_step_size>0.001</max_step_size>        \x3c!-- Simulation time step (seconds) --\x3e\n<real_time_update_rate>1000.0</real_time_update_rate>  \x3c!-- Updates per second --\x3e\n<real_time_factor>1.0</real_time_factor>    \x3c!-- Simulation speed multiplier --\x3e\n"})}),"\n",(0,s.jsx)(e.p,{children:"For humanoid robots requiring precise control:"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Smaller time steps (0.001s) for better accuracy"}),"\n",(0,s.jsx)(e.li,{children:"Higher update rates for responsive control"}),"\n",(0,s.jsx)(e.li,{children:"Real-time factor of 1.0 for real-time simulation"}),"\n"]}),"\n",(0,s.jsx)(e.h2,{id:"collision-detection-and-dynamics",children:"Collision Detection and Dynamics"}),"\n",(0,s.jsx)(e.h3,{id:"collision-properties",children:"Collision Properties"}),"\n",(0,s.jsx)(e.p,{children:"Each link in a robot model needs proper collision properties:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-xml",children:'<link name="link_name">\n  <collision name="collision">\n    <geometry>\n      <box>\n        <size>0.1 0.1 0.1</size>\n      </box>\n    </geometry>\n    <surface>\n      <friction>\n        <ode>\n          <mu>1.0</mu>    \x3c!-- Static friction coefficient --\x3e\n          <mu2>1.0</mu2>  \x3c!-- Secondary friction coefficient --\x3e\n        </ode>\n      </friction>\n      <bounce>\n        <restitution_coefficient>0.0</restitution_coefficient>  \x3c!-- Bounciness --\x3e\n        <threshold>100000.0</threshold>  \x3c!-- Velocity threshold for bouncing --\x3e\n      </bounce>\n      <contact>\n        <ode>\n          <kp>1e+16</kp>  \x3c!-- Contact stiffness --\x3e\n          <kd>1e+12</kd>  \x3c!-- Contact damping --\x3e\n          <max_vel>100.0</max_vel>  \x3c!-- Maximum contact correction velocity --\x3e\n          <min_depth>0.001</min_depth>  \x3c!-- Minimum contact depth --\x3e\n        </ode>\n      </contact>\n    </surface>\n  </collision>\n</link>\n'})}),"\n",(0,s.jsx)(e.h3,{id:"material-properties-for-humanoid-simulation",children:"Material Properties for Humanoid Simulation"}),"\n",(0,s.jsx)(e.p,{children:"For realistic humanoid interaction with the environment:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-xml",children:'\x3c!-- Feet with good grip for walking --\x3e\n<collision name="left_foot_collision">\n  <geometry>\n    <box>\n      <size>0.15 0.08 0.01</size>\n    </box>\n  </geometry>\n  <surface>\n    <friction>\n      <ode>\n        <mu>1.5</mu>   \x3c!-- High friction for stable walking --\x3e\n        <mu2>1.5</mu2>\n      </ode>\n    </friction>\n  </surface>\n</collision>\n'})}),"\n",(0,s.jsx)(e.h2,{id:"building-custom-simulation-environments",children:"Building Custom Simulation Environments"}),"\n",(0,s.jsx)(e.h3,{id:"using-gazebos-building-editor",children:"Using Gazebo's Building Editor"}),"\n",(0,s.jsx)(e.p,{children:"Gazebo provides a building editor for creating custom environments:"}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsx)(e.li,{children:"Launch Gazebo with the building plugin:"}),"\n"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-bash",children:"gz sim -r -v 4 building_warehouse.sdf\n"})}),"\n",(0,s.jsxs)(e.ol,{start:"2",children:["\n",(0,s.jsxs)(e.li,{children:["Use the building editor to create:","\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Rooms with walls, doors, windows"}),"\n",(0,s.jsx)(e.li,{children:"Furniture and obstacles"}),"\n",(0,s.jsx)(e.li,{children:"Multi-story buildings"}),"\n",(0,s.jsx)(e.li,{children:"Complex architectural structures"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(e.h3,{id:"creating-custom-world-files",children:"Creating Custom World Files"}),"\n",(0,s.jsx)(e.p,{children:"Basic world file structure:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-xml",children:'<sdf version="1.7">\n  <world name="humanoid_training_world">\n    \x3c!-- Physics configuration --\x3e\n    <physics type="ode">\n      <max_step_size>0.001</max_step_size>\n      <real_time_factor>1.0</real_time_factor>\n      <gravity>0 0 -9.8</gravity>\n    </physics>\n\n    \x3c!-- Lighting --\x3e\n    <include>\n      <uri>model://sun</uri>\n    </include>\n\n    \x3c!-- Ground plane --\x3e\n    <include>\n      <uri>model://ground_plane</uri>\n    </include>\n\n    \x3c!-- Custom models --\x3e\n    <include>\n      <uri>model://my_humanoid_robot</uri>\n      <pose>0 0 1 0 0 0</pose>\n    </include>\n\n    \x3c!-- Obstacles for training --\x3e\n    <model name="training_obstacle_1">\n      <pose>2 0 0.5 0 0 0</pose>\n      <link name="link">\n        <collision name="collision">\n          <geometry>\n            <box>\n              <size>0.5 0.5 1.0</size>\n            </box>\n          </geometry>\n        </collision>\n        <visual name="visual">\n          <geometry>\n            <box>\n              <size>0.5 0.5 1.0</size>\n            </box>\n          </geometry>\n          <material>\n            <ambient>0.8 0.2 0.2 1</ambient>\n            <diffuse>1 0.3 0.3 1</diffuse>\n          </material>\n        </visual>\n      </link>\n    </model>\n  </world>\n</sdf>\n'})}),"\n",(0,s.jsx)(e.h3,{id:"environment-elements-for-humanoid-training",children:"Environment Elements for Humanoid Training"}),"\n",(0,s.jsx)(e.h4,{id:"flat-ground-area",children:"Flat Ground Area"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-xml",children:'\x3c!-- Large flat area for basic locomotion training --\x3e\n<model name="training_area">\n  <pose>0 0 0 0 0 0</pose>\n  <static>true</static>\n  <link name="link">\n    <collision name="collision">\n      <geometry>\n        <box>\n          <size>20 20 0.1</size>\n        </box>\n      </geometry>\n    </collision>\n    <visual name="visual">\n      <geometry>\n        <box>\n          <size>20 20 0.1</size>\n        </box>\n      </geometry>\n      <material>\n        <ambient>0.6 0.6 0.6 1</ambient>\n        <diffuse>0.7 0.7 0.7 1</diffuse>\n      </material>\n    </visual>\n  </link>\n</model>\n'})}),"\n",(0,s.jsx)(e.h4,{id:"obstacle-course",children:"Obstacle Course"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-xml",children:'\x3c!-- Various obstacles for navigation training --\x3e\n<model name="narrow_passage">\n  <pose>5 0 0.5 0 0 0</pose>\n  <link name="left_wall">\n    <collision name="collision">\n      <geometry>\n        <box>\n          <size>0.1 2.0 2.0</size>\n        </box>\n      </geometry>\n    </collision>\n  </link>\n  <link name="right_wall">\n    <pose>1.9 0 0 0 0 0</pose>\n    <collision name="collision">\n      <geometry>\n        <box>\n          <size>0.1 2.0 2.0</size>\n        </box>\n      </geometry>\n    </collision>\n  </link>\n</model>\n'})}),"\n",(0,s.jsx)(e.h2,{id:"gazebo-ros-2-integration",children:"Gazebo-ROS 2 Integration"}),"\n",(0,s.jsx)(e.h3,{id:"launching-gazebo-with-ros-2",children:"Launching Gazebo with ROS 2"}),"\n",(0,s.jsx)(e.p,{children:"To integrate Gazebo with ROS 2, use the gazebo_ros packages:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-xml",children:'\x3c!-- In your launch file --\x3e\n<launch>\n  \x3c!-- Start Gazebo server --\x3e\n  <node name="gazebo_server" pkg="gazebo_ros" exec="gzserver" args="$(find-pkg-share my_robot_gazebo)/worlds/my_world.sdf"/>\n\n  \x3c!-- Start Gazebo client --\x3e\n  <node name="gazebo_client" pkg="gazebo_ros" exec="gzclient"/>\n</launch>\n'})}),"\n",(0,s.jsx)(e.h3,{id:"spawning-robots-in-gazebo",children:"Spawning Robots in Gazebo"}),"\n",(0,s.jsx)(e.p,{children:"Use the spawn_entity service to place robots in the simulation:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:"import rclpy\nfrom rclpy.node import Node\nfrom gazebo_msgs.srv import SpawnEntity\n\nclass RobotSpawner(Node):\n    def __init__(self):\n        super().__init__('robot_spawner')\n        self.cli = self.create_client(SpawnEntity, '/spawn_entity')\n        while not self.cli.wait_for_service(timeout_sec=1.0):\n            self.get_logger().info('Service not available, waiting again...')\n\n    def spawn_robot(self, robot_name, robot_xml, x, y, z, roll, pitch, yaw):\n        req = SpawnEntity.Request()\n        req.name = robot_name\n        req.xml = robot_xml\n        req.initial_pose.position.x = x\n        req.initial_pose.position.y = y\n        req.initial_pose.position.z = z\n        req.initial_pose.orientation = self.euler_to_quaternion(roll, pitch, yaw)\n\n        future = self.cli.call_async(req)\n        return future\n\ndef main(args=None):\n    rclpy.init(args=args)\n    spawner = RobotSpawner()\n    # Spawn your humanoid robot\n    future = spawner.spawn_robot(\"my_humanoid\", robot_xml_content, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0)\n    rclpy.spin_until_future_complete(spawner, future)\n    spawner.destroy_node()\n    rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,s.jsx)(e.h2,{id:"performance-optimization-for-humanoid-simulation",children:"Performance Optimization for Humanoid Simulation"}),"\n",(0,s.jsx)(e.h3,{id:"reducing-computational-load",children:"Reducing Computational Load"}),"\n",(0,s.jsx)(e.p,{children:"For complex humanoid models with many joints:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-xml",children:'\x3c!-- Optimize physics for humanoid simulation --\x3e\n<physics type="ode">\n  <max_step_size>0.001</max_step_size>\n  <real_time_factor>1.0</real_time_factor>\n  \x3c!-- Use fewer threads for better humanoid control responsiveness --\x3e\n  <threads>4</threads>\n  \x3c!-- Adjust solver iterations for balance between accuracy and speed --\x3e\n  <ode>\n    <solver>\n      <type>quick</type>\n      <iters>100</iters>\n      <sor>1.3</sor>\n    </solver>\n    <constraints>\n      <cfm>0.0</cfm>\n      <erp>0.2</erp>\n      <contact_max_correcting_vel>100.0</contact_max_correcting_vel>\n      <contact_surface_layer>0.001</contact_surface_layer>\n    </constraints>\n  </ode>\n</physics>\n'})}),"\n",(0,s.jsx)(e.h3,{id:"visual-optimization",children:"Visual Optimization"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-xml>",children:"\x3c!-- Optimize visual rendering for humanoid simulation --\x3e\n<scene>\n  <grid>false</grid>  \x3c!-- Disable grid for performance --\x3e\n  <shadows>false</shadows>  \x3c!-- Optional: disable shadows for performance --\x3e\n  <ambient>0.4 0.4 0.4 1</ambient>  \x3c!-- Adjust lighting for performance --\x3e\n</scene>\n"})}),"\n",(0,s.jsx)(e.h2,{id:"troubleshooting-common-issues",children:"Troubleshooting Common Issues"}),"\n",(0,s.jsx)(e.h3,{id:"robot-falling-through-ground",children:"Robot Falling Through Ground"}),"\n",(0,s.jsx)(e.p,{children:"Common causes and solutions:"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Check collision geometry in URDF/SDF"}),"\n",(0,s.jsx)(e.li,{children:"Verify physics parameters (contact stiffness/damping)"}),"\n",(0,s.jsx)(e.li,{children:"Ensure proper mass and inertia values"}),"\n"]}),"\n",(0,s.jsx)(e.h3,{id:"unstable-simulation",children:"Unstable Simulation"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Reduce time step size"}),"\n",(0,s.jsx)(e.li,{children:"Adjust solver parameters"}),"\n",(0,s.jsx)(e.li,{children:"Check joint limits and constraints"}),"\n"]}),"\n",(0,s.jsx)(e.h3,{id:"performance-issues",children:"Performance Issues"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Simplify collision geometry (use boxes instead of meshes)"}),"\n",(0,s.jsx)(e.li,{children:"Reduce visual complexity"}),"\n",(0,s.jsx)(e.li,{children:"Adjust physics parameters for speed vs. accuracy"}),"\n"]}),"\n",(0,s.jsx)(e.h2,{id:"summary",children:"Summary"}),"\n",(0,s.jsx)(e.p,{children:"This chapter introduced the fundamentals of Gazebo simulation for humanoid robotics, including:"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Installation and setup procedures"}),"\n",(0,s.jsx)(e.li,{children:"Physics simulation configuration with gravity and collision detection"}),"\n",(0,s.jsx)(e.li,{children:"Environment building for humanoid robot training"}),"\n",(0,s.jsx)(e.li,{children:"Integration with ROS 2 for complete simulation workflows"}),"\n",(0,s.jsx)(e.li,{children:"Performance optimization techniques for complex humanoid models"}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:"Gazebo provides a robust platform for developing, testing, and training humanoid robots in a safe virtual environment before real-world deployment. The combination of accurate physics simulation, realistic sensor modeling, and ROS 2 integration makes it an essential tool for humanoid robotics development."})]})}function u(n={}){const{wrapper:e}={...(0,r.R)(),...n.components};return e?(0,s.jsx)(e,{...n,children:(0,s.jsx)(d,{...n})}):d(n)}},8453(n,e,i){i.d(e,{R:()=>t,x:()=>l});var o=i(6540);const s={},r=o.createContext(s);function t(n){const e=o.useContext(r);return o.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function l(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(s):n.components||s:t(n.components),o.createElement(r.Provider,{value:e},n.children)}}}]);