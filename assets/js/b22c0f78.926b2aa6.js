"use strict";(globalThis.webpackChunkphysical_humanoid_ai_book=globalThis.webpackChunkphysical_humanoid_ai_book||[]).push([[445],{5433(n,i,e){e.r(i),e.d(i,{assets:()=>s,contentTitle:()=>a,default:()=>m,frontMatter:()=>t,metadata:()=>o,toc:()=>d});const o=JSON.parse('{"id":"module2-digital-twin/chapter2-urdf-sdf-modeling","title":"Chapter 2: Robot Description Formats - URDF and SDF for Humanoid Modeling","description":"Learning Objectives","source":"@site/docs/module2-digital-twin/chapter2-urdf-sdf-modeling.md","sourceDirName":"module2-digital-twin","slug":"/module2-digital-twin/chapter2-urdf-sdf-modeling","permalink":"/physical-humanoid-ai-book/docs/module2-digital-twin/chapter2-urdf-sdf-modeling","draft":false,"unlisted":false,"editUrl":"https://github.com/alizah-fatima/physical-humanoid-ai-book/tree/main/docs/module2-digital-twin/chapter2-urdf-sdf-modeling.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"sidebar_position":2},"sidebar":"tutorialSidebar","previous":{"title":"Chapter 1: Introduction to Gazebo - Physics Simulation for Humanoid Robotics","permalink":"/physical-humanoid-ai-book/docs/module2-digital-twin/chapter1-gazebo-intro"},"next":{"title":"Chapter 3: Sensor Simulation and Unity Integration for High-Fidelity Rendering","permalink":"/physical-humanoid-ai-book/docs/module2-digital-twin/chapter3-sensor-unity-integration"}}');var r=e(4848),l=e(8453);const t={sidebar_position:2},a="Chapter 2: Robot Description Formats - URDF and SDF for Humanoid Modeling",s={},d=[{value:"Learning Objectives",id:"learning-objectives",level:2},{value:"Introduction to Robot Description Formats",id:"introduction-to-robot-description-formats",level:2},{value:"URDF vs SDF: Key Differences",id:"urdf-vs-sdf-key-differences",level:2},{value:"URDF (Unified Robot Description Format)",id:"urdf-unified-robot-description-format",level:3},{value:"SDF (Simulation Description Format)",id:"sdf-simulation-description-format",level:3},{value:"When to Use Each Format",id:"when-to-use-each-format",level:3},{value:"URDF for Humanoid Robots",id:"urdf-for-humanoid-robots",level:2},{value:"Basic URDF Structure",id:"basic-urdf-structure",level:3},{value:"Humanoid-Specific URDF Considerations",id:"humanoid-specific-urdf-considerations",level:3},{value:"Joint Types for Humanoid Robots",id:"joint-types-for-humanoid-robots",level:4},{value:"Mass Distribution for Humanoid Balance",id:"mass-distribution-for-humanoid-balance",level:4},{value:"SDF for Gazebo Simulation",id:"sdf-for-gazebo-simulation",level:2},{value:"Converting URDF to SDF",id:"converting-urdf-to-sdf",level:3},{value:"Gazebo-Specific Extensions in SDF",id:"gazebo-specific-extensions-in-sdf",level:3},{value:"Physics Properties",id:"physics-properties",level:4},{value:"Gazebo Plugins",id:"gazebo-plugins",level:4},{value:"Complete Humanoid Robot Model Example",id:"complete-humanoid-robot-model-example",level:2},{value:"URDF with Xacro for Complex Humanoid",id:"urdf-with-xacro-for-complex-humanoid",level:3},{value:"SDF Version with Gazebo Plugins",id:"sdf-version-with-gazebo-plugins",level:3},{value:"Converting Between URDF and SDF",id:"converting-between-urdf-and-sdf",level:2},{value:"Using xacro to Generate SDF from URDF",id:"using-xacro-to-generate-sdf-from-urdf",level:3},{value:"ROS 2 Launch Integration",id:"ros-2-launch-integration",level:3},{value:"Optimization Techniques for Simulation",id:"optimization-techniques-for-simulation",level:2},{value:"Simplified Collision Models",id:"simplified-collision-models",level:3},{value:"Hierarchical Model Organization",id:"hierarchical-model-organization",level:3},{value:"Best Practices for Humanoid Modeling",id:"best-practices-for-humanoid-modeling",level:2},{value:"1. Realistic Mass Distribution",id:"1-realistic-mass-distribution",level:3},{value:"2. Appropriate Joint Limits",id:"2-appropriate-joint-limits",level:3},{value:"3. Stable Simulation Parameters",id:"3-stable-simulation-parameters",level:3},{value:"4. Model Validation",id:"4-model-validation",level:3},{value:"Troubleshooting Common Issues",id:"troubleshooting-common-issues",level:2},{value:"Robot Falls Through Ground",id:"robot-falls-through-ground",level:3},{value:"Unstable Joint Behavior",id:"unstable-joint-behavior",level:3},{value:"Performance Issues",id:"performance-issues",level:3},{value:"Summary",id:"summary",level:2}];function c(n){const i={code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,l.R)(),...n.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(i.header,{children:(0,r.jsx)(i.h1,{id:"chapter-2-robot-description-formats---urdf-and-sdf-for-humanoid-modeling",children:"Chapter 2: Robot Description Formats - URDF and SDF for Humanoid Modeling"})}),"\n",(0,r.jsx)(i.h2,{id:"learning-objectives",children:"Learning Objectives"}),"\n",(0,r.jsx)(i.p,{children:"By the end of this chapter, you will be able to:"}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsx)(i.li,{children:"Understand the differences between URDF and SDF formats"}),"\n",(0,r.jsx)(i.li,{children:"Create humanoid robot models using both URDF and SDF"}),"\n",(0,r.jsx)(i.li,{children:"Configure simulation-specific properties in SDF"}),"\n",(0,r.jsx)(i.li,{children:"Convert between URDF and SDF formats when needed"}),"\n",(0,r.jsx)(i.li,{children:"Optimize robot models for Gazebo simulation"}),"\n"]}),"\n",(0,r.jsx)(i.h2,{id:"introduction-to-robot-description-formats",children:"Introduction to Robot Description Formats"}),"\n",(0,r.jsx)(i.p,{children:"Robot description formats are essential for defining the physical and visual properties of robots in simulation environments. Two primary formats are used in robotics:"}),"\n",(0,r.jsxs)(i.ol,{children:["\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"URDF (Unified Robot Description Format)"}),": Primarily used in ROS/ROS 2 for robot description"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"SDF (Simulation Description Format)"}),": Used by Gazebo for simulation-specific properties"]}),"\n"]}),"\n",(0,r.jsx)(i.p,{children:"Both formats define the robot's structure, but they serve different purposes in the robotics pipeline."}),"\n",(0,r.jsx)(i.h2,{id:"urdf-vs-sdf-key-differences",children:"URDF vs SDF: Key Differences"}),"\n",(0,r.jsx)(i.h3,{id:"urdf-unified-robot-description-format",children:"URDF (Unified Robot Description Format)"}),"\n",(0,r.jsx)(i.p,{children:"URDF is an XML-based format that describes robot structure and kinematics. It's the standard for ROS/ROS 2 and focuses on:"}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsx)(i.li,{children:"Kinematic structure (links and joints)"}),"\n",(0,r.jsx)(i.li,{children:"Visual and collision properties"}),"\n",(0,r.jsx)(i.li,{children:"Inertial properties"}),"\n",(0,r.jsx)(i.li,{children:"Basic sensor information"}),"\n"]}),"\n",(0,r.jsx)(i.h3,{id:"sdf-simulation-description-format",children:"SDF (Simulation Description Format)"}),"\n",(0,r.jsx)(i.p,{children:"SDF is an XML-based format designed specifically for simulation. It includes:"}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsx)(i.li,{children:"All URDF properties"}),"\n",(0,r.jsx)(i.li,{children:"Simulation-specific physics parameters"}),"\n",(0,r.jsx)(i.li,{children:"Gazebo plugins and extensions"}),"\n",(0,r.jsx)(i.li,{children:"Environment-specific properties"}),"\n",(0,r.jsx)(i.li,{children:"Advanced sensor simulation parameters"}),"\n"]}),"\n",(0,r.jsx)(i.h3,{id:"when-to-use-each-format",children:"When to Use Each Format"}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"URDF"}),": When working with ROS/ROS 2, kinematic analysis, and robot control"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"SDF"}),": When working with Gazebo simulation, advanced physics, and simulation plugins"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Conversion"}),": URDF can be converted to SDF for simulation using xacro and Gazebo tools"]}),"\n"]}),"\n",(0,r.jsx)(i.h2,{id:"urdf-for-humanoid-robots",children:"URDF for Humanoid Robots"}),"\n",(0,r.jsx)(i.h3,{id:"basic-urdf-structure",children:"Basic URDF Structure"}),"\n",(0,r.jsx)(i.pre,{children:(0,r.jsx)(i.code,{className:"language-xml",children:'<?xml version="1.0"?>\n<robot name="humanoid_robot" xmlns:xacro="http://www.ros.org/wiki/xacro">\n  \x3c!-- Links (rigid bodies) --\x3e\n  <link name="base_link">\n    <inertial>\n      <mass value="10.0"/>\n      <origin xyz="0 0 0.1" rpy="0 0 0"/>\n      <inertia ixx="0.1" ixy="0" ixz="0" iyy="0.1" iyz="0" izz="0.1"/>\n    </inertial>\n    <visual>\n      <origin xyz="0 0 0.1" rpy="0 0 0"/>\n      <geometry>\n        <box size="0.3 0.3 0.2"/>\n      </geometry>\n      <material name="blue">\n        <color rgba="0 0 1 1"/>\n      </material>\n    </visual>\n    <collision>\n      <origin xyz="0 0 0.1" rpy="0 0 0"/>\n      <geometry>\n        <box size="0.3 0.3 0.2"/>\n      </geometry>\n    </collision>\n  </link>\n\n  \x3c!-- Joints connecting links --\x3e\n  <joint name="torso_joint" type="fixed">\n    <parent link="base_link"/>\n    <child link="torso"/>\n    <origin xyz="0 0 0.2" rpy="0 0 0"/>\n  </joint>\n\n  <link name="torso">\n    <inertial>\n      <mass value="8.0"/>\n      <origin xyz="0 0 0.25" rpy="0 0 0"/>\n      <inertia ixx="0.2" ixy="0" ixz="0" iyy="0.2" iyz="0" izz="0.1"/>\n    </inertial>\n    <visual>\n      <origin xyz="0 0 0.25" rpy="0 0 0"/>\n      <geometry>\n        <box size="0.25 0.2 0.5"/>\n      </geometry>\n    </visual>\n    <collision>\n      <origin xyz="0 0 0.25" rpy="0 0 0"/>\n      <geometry>\n        <box size="0.25 0.2 0.5"/>\n      </geometry>\n    </collision>\n  </link>\n</robot>\n'})}),"\n",(0,r.jsx)(i.h3,{id:"humanoid-specific-urdf-considerations",children:"Humanoid-Specific URDF Considerations"}),"\n",(0,r.jsx)(i.h4,{id:"joint-types-for-humanoid-robots",children:"Joint Types for Humanoid Robots"}),"\n",(0,r.jsx)(i.pre,{children:(0,r.jsx)(i.code,{className:"language-xml",children:'\x3c!-- Revolute joints for human-like movement --\x3e\n<joint name="left_hip_joint" type="revolute">\n  <parent link="torso"/>\n  <child link="left_thigh"/>\n  <origin xyz="0.1 -0.1 -0.25" rpy="0 0 0"/>\n  <axis xyz="0 0 1"/>\n  <limit lower="-1.57" upper="1.57" effort="100" velocity="2"/>\n  <dynamics damping="1.0" friction="0.1"/>\n</joint>\n\n\x3c!-- Continuous joints for unlimited rotation --\x3e\n<joint name="left_knee_joint" type="revolute">\n  <parent link="left_thigh"/>\n  <child link="left_shin"/>\n  <origin xyz="0 0 -0.4" rpy="0 0 0"/>\n  <axis xyz="0 1 0"/>\n  <limit lower="0" upper="2.35" effort="100" velocity="2"/>\n</joint>\n\n\x3c!-- Spherical joints for ball-and-socket movement (using 3 revolute joints) --\x3e\n<joint name="left_shoulder_joint_yaw" type="revolute">\n  <parent link="torso"/>\n  <child link="left_upper_arm_yaw"/>\n  <origin xyz="0.15 0.1 0.1" rpy="0 0 0"/>\n  <axis xyz="0 0 1"/>\n  <limit lower="-1.57" upper="1.57" effort="50" velocity="2"/>\n</joint>\n'})}),"\n",(0,r.jsx)(i.h4,{id:"mass-distribution-for-humanoid-balance",children:"Mass Distribution for Humanoid Balance"}),"\n",(0,r.jsx)(i.pre,{children:(0,r.jsx)(i.code,{className:"language-xml",children:'\x3c!-- Realistic mass distribution for stable simulation --\x3e\n<link name="torso">\n  <inertial>\n    <mass value="15.0"/> \x3c!-- Heavier torso for stability --\x3e\n    <origin xyz="0 0 0.2" rpy="0 0 0"/>\n    <inertia ixx="0.8" ixy="0" ixz="0" iyy="0.6" iyz="0" izz="0.3"/>\n  </inertial>\n</link>\n\n<link name="head">\n  <inertial>\n    <mass value="3.0"/> \x3c!-- Realistic head mass --\x3e\n    <origin xyz="0 0 0.05" rpy="0 0 0"/>\n    <inertia ixx="0.02" ixy="0" ixz="0" iyy="0.02" iyz="0" izz="0.02"/>\n  </inertial>\n</link>\n'})}),"\n",(0,r.jsx)(i.h2,{id:"sdf-for-gazebo-simulation",children:"SDF for Gazebo Simulation"}),"\n",(0,r.jsx)(i.h3,{id:"converting-urdf-to-sdf",children:"Converting URDF to SDF"}),"\n",(0,r.jsx)(i.p,{children:"When URDF is loaded into Gazebo, it's automatically converted to SDF. However, you can also create native SDF files:"}),"\n",(0,r.jsx)(i.pre,{children:(0,r.jsx)(i.code,{className:"language-xml",children:'<?xml version="1.0"?>\n<sdf version="1.7">\n  <model name="humanoid_robot">\n    \x3c!-- Base link --\x3e\n    <link name="base_link">\n      <pose>0 0 0.1 0 0 0</pose>\n      <inertial>\n        <mass>10.0</mass>\n        <inertia>\n          <ixx>0.1</ixx>\n          <ixy>0</ixy>\n          <ixz>0</ixz>\n          <iyy>0.1</iyy>\n          <iyz>0</iyz>\n          <izz>0.1</izz>\n        </inertia>\n      </inertial>\n\n      <visual name="visual">\n        <geometry>\n          <box>\n            <size>0.3 0.3 0.2</size>\n          </box>\n        </geometry>\n        <material>\n          <ambient>0 0 1 1</ambient>\n          <diffuse>0 0 1 1</diffuse>\n        </material>\n      </visual>\n\n      <collision name="collision">\n        <geometry>\n          <box>\n            <size>0.3 0.3 0.2</size>\n          </box>\n        </geometry>\n      </collision>\n    </link>\n\n    \x3c!-- Joint --\x3e\n    <joint name="torso_joint" type="fixed">\n      <parent>base_link</parent>\n      <child>torso</child>\n    </joint>\n\n    <link name="torso">\n      <pose>0 0 0.3 0 0 0</pose>\n      <inertial>\n        <mass>8.0</mass>\n        <inertia>\n          <ixx>0.2</ixx>\n          <ixy>0</ixy>\n          <ixz>0</ixz>\n          <iyy>0.2</iyy>\n          <iyz>0</iyz>\n          <izz>0.1</izz>\n        </inertia>\n      </inertial>\n\n      <visual name="visual">\n        <geometry>\n          <box>\n            <size>0.25 0.2 0.5</size>\n          </box>\n        </geometry>\n      </visual>\n\n      <collision name="collision">\n        <geometry>\n          <box>\n            <size>0.25 0.2 0.5</size>\n          </box>\n        </geometry>\n      </collision>\n    </link>\n  </model>\n</sdf>\n'})}),"\n",(0,r.jsx)(i.h3,{id:"gazebo-specific-extensions-in-sdf",children:"Gazebo-Specific Extensions in SDF"}),"\n",(0,r.jsx)(i.h4,{id:"physics-properties",children:"Physics Properties"}),"\n",(0,r.jsx)(i.pre,{children:(0,r.jsx)(i.code,{className:"language-xml",children:'<link name="left_foot">\n  <inertial>\n    <mass>1.5</mass>\n    <inertia>\n      <ixx>0.005</ixx>\n      <ixy>0</ixy>\n      <ixz>0</ixz>\n      <iyy>0.005</iyy>\n      <iyz>0</iyz>\n      <izz>0.001</izz>\n    </inertia>\n  </inertial>\n\n  <collision name="collision">\n    <geometry>\n      <box>\n        <size>0.15 0.08 0.01</size>\n      </box>\n    </geometry>\n    \x3c!-- Gazebo-specific surface properties --\x3e\n    <surface>\n      <friction>\n        <ode>\n          <mu>1.5</mu>    \x3c!-- High friction for stable walking --\x3e\n          <mu2>1.5</mu2>\n        </ode>\n      </friction>\n      <bounce>\n        <restitution_coefficient>0.0</restitution_coefficient>\n      </bounce>\n    </surface>\n  </collision>\n</link>\n'})}),"\n",(0,r.jsx)(i.h4,{id:"gazebo-plugins",children:"Gazebo Plugins"}),"\n",(0,r.jsx)(i.pre,{children:(0,r.jsx)(i.code,{className:"language-xml",children:'\x3c!-- Gazebo plugins for simulation --\x3e\n<gazebo reference="left_foot">\n  <material>Gazebo/Blue</material>\n  <mu1>1.5</mu1>\n  <mu2>1.5</mu2>\n  <kp>1000000.0</kp>  \x3c!-- Contact stiffness --\x3e\n  <kd>100.0</kd>      \x3c!-- Contact damping --\x3e\n</gazebo>\n\n\x3c!-- Sensor plugin --\x3e\n<gazebo reference="head_camera">\n  <sensor name="head_camera" type="camera">\n    <camera name="head_camera">\n      <horizontal_fov>1.047</horizontal_fov>\n      <image>\n        <width>640</width>\n        <height>480</height>\n        <format>R8G8B8</format>\n      </image>\n      <clip>\n        <near>0.1</near>\n        <far>10.0</far>\n      </clip>\n    </camera>\n    <always_on>1</always_on>\n    <update_rate>30</update_rate>\n    <visualize>true</visualize>\n  </sensor>\n</gazebo>\n'})}),"\n",(0,r.jsx)(i.h2,{id:"complete-humanoid-robot-model-example",children:"Complete Humanoid Robot Model Example"}),"\n",(0,r.jsx)(i.h3,{id:"urdf-with-xacro-for-complex-humanoid",children:"URDF with Xacro for Complex Humanoid"}),"\n",(0,r.jsx)(i.pre,{children:(0,r.jsx)(i.code,{className:"language-xml",children:'<?xml version="1.0"?>\n<robot name="simple_humanoid" xmlns:xacro="http://www.ros.org/wiki/xacro">\n\n  \x3c!-- Properties --\x3e\n  <xacro:property name="M_PI" value="3.1415926535897931"/>\n  <xacro:property name="torso_mass" value="15.0"/>\n  <xacro:property name="head_mass" value="3.0"/>\n  <xacro:property name="arm_mass" value="2.0"/>\n  <xacro:property name="leg_mass" value="5.0"/>\n\n  \x3c!-- Base footprint --\x3e\n  <link name="base_footprint">\n    <inertial>\n      <mass value="0.0001"/>\n      <origin xyz="0 0 0" rpy="0 0 0"/>\n      <inertia ixx="0.0001" ixy="0" ixz="0" iyy="0.0001" iyz="0" izz="0.0001"/>\n    </inertial>\n  </link>\n\n  <joint name="base_joint" type="fixed">\n    <parent link="base_footprint"/>\n    <child link="base_link"/>\n    <origin xyz="0 0 0.05" rpy="0 0 0"/>\n  </joint>\n\n  \x3c!-- Base link --\x3e\n  <link name="base_link">\n    <inertial>\n      <mass value="0.5"/>\n      <origin xyz="0 0 0.05" rpy="0 0 0"/>\n      <inertia ixx="0.001" ixy="0" ixz="0" iyy="0.001" iyz="0" izz="0.001"/>\n    </inertial>\n    <visual>\n      <origin xyz="0 0 0.05" rpy="0 0 0"/>\n      <geometry>\n        <cylinder radius="0.05" length="0.1"/>\n      </geometry>\n    </visual>\n    <collision>\n      <origin xyz="0 0 0.05" rpy="0 0 0"/>\n      <geometry>\n        <cylinder radius="0.05" length="0.1"/>\n      </geometry>\n    </collision>\n  </link>\n\n  \x3c!-- Torso --\x3e\n  <joint name="torso_joint" type="fixed">\n    <parent link="base_link"/>\n    <child link="torso"/>\n    <origin xyz="0 0 0.1" rpy="0 0 0"/>\n  </joint>\n\n  <link name="torso">\n    <inertial>\n      <mass value="${torso_mass}"/>\n      <origin xyz="0 0 0.25" rpy="0 0 0"/>\n      <inertia ixx="0.8" ixy="0" ixz="0" iyy="0.6" iyz="0" izz="0.3"/>\n    </inertial>\n    <visual>\n      <origin xyz="0 0 0.25" rpy="0 0 0"/>\n      <geometry>\n        <box size="0.25 0.2 0.5"/>\n      </geometry>\n      <material name="light_gray">\n        <color rgba="0.7 0.7 0.7 1"/>\n      </material>\n    </visual>\n    <collision>\n      <origin xyz="0 0 0.25" rpy="0 0 0"/>\n      <geometry>\n        <box size="0.25 0.2 0.5"/>\n      </geometry>\n    </collision>\n  </link>\n\n  \x3c!-- Head --\x3e\n  <joint name="neck_joint" type="revolute">\n    <parent link="torso"/>\n    <child link="head"/>\n    <origin xyz="0 0 0.5" rpy="0 0 0"/>\n    <axis xyz="0 1 0"/>\n    <limit lower="${-M_PI/4}" upper="${M_PI/4}" effort="10" velocity="1"/>\n  </joint>\n\n  <link name="head">\n    <inertial>\n      <mass value="${head_mass}"/>\n      <origin xyz="0 0 0.05" rpy="0 0 0"/>\n      <inertia ixx="0.02" ixy="0" ixz="0" iyy="0.02" iyz="0" izz="0.02"/>\n    </inertial>\n    <visual>\n      <origin xyz="0 0 0.05" rpy="0 0 0"/>\n      <geometry>\n        <sphere radius="0.1"/>\n      </geometry>\n      <material name="skin">\n        <color rgba="0.8 0.6 0.4 1"/>\n      </material>\n    </visual>\n    <collision>\n      <origin xyz="0 0 0.05" rpy="0 0 0"/>\n      <geometry>\n        <sphere radius="0.1"/>\n      </geometry>\n    </collision>\n  </link>\n\n  \x3c!-- Left Arm --\x3e\n  <joint name="left_shoulder_yaw" type="revolute">\n    <parent link="torso"/>\n    <child link="left_upper_arm_yaw"/>\n    <origin xyz="0.15 0.1 0.2" rpy="0 0 0"/>\n    <axis xyz="0 0 1"/>\n    <limit lower="${-M_PI/2}" upper="${M_PI/2}" effort="50" velocity="2"/>\n  </joint>\n\n  <link name="left_upper_arm_yaw">\n    <inertial>\n      <mass value="${arm_mass/3}"/>\n      <origin xyz="0 0 0.1" rpy="0 0 0"/>\n      <inertia ixx="0.01" ixy="0" ixz="0" iyy="0.01" iyz="0" izz="0.001"/>\n    </inertial>\n    <visual>\n      <origin xyz="0 0 0.1" rpy="0 0 0"/>\n      <geometry>\n        <cylinder radius="0.04" length="0.2"/>\n      </geometry>\n    </visual>\n    <collision>\n      <origin xyz="0 0 0.1" rpy="0 0 0"/>\n      <geometry>\n        <cylinder radius="0.04" length="0.2"/>\n      </geometry>\n    </collision>\n  </link>\n\n  <joint name="left_shoulder_pitch" type="revolute">\n    <parent link="left_upper_arm_yaw"/>\n    <child link="left_upper_arm"/>\n    <origin xyz="0 0 0.2" rpy="0 0 0"/>\n    <axis xyz="0 1 0"/>\n    <limit lower="${-M_PI/2}" upper="${M_PI}" effort="50" velocity="2"/>\n  </joint>\n\n  <link name="left_upper_arm">\n    <inertial>\n      <mass value="${arm_mass/2}"/>\n      <origin xyz="0 0 0.15" rpy="0 0 0"/>\n      <inertia ixx="0.01" ixy="0" ixz="0" iyy="0.01" iyz="0" izz="0.001"/>\n    </inertial>\n    <visual>\n      <origin xyz="0 0 0.15" rpy="0 0 0"/>\n      <geometry>\n        <cylinder radius="0.04" length="0.3"/>\n      </geometry>\n    </visual>\n    <collision>\n      <origin xyz="0 0 0.15" rpy="0 0 0"/>\n      <geometry>\n        <cylinder radius="0.04" length="0.3"/>\n      </geometry>\n    </collision>\n  </link>\n\n  <joint name="left_elbow" type="revolute">\n    <parent link="left_upper_arm"/>\n    <child link="left_lower_arm"/>\n    <origin xyz="0 0 0.3" rpy="0 0 0"/>\n    <axis xyz="0 0 1"/>\n    <limit lower="${-M_PI}" upper="${M_PI/2}" effort="30" velocity="2"/>\n  </joint>\n\n  <link name="left_lower_arm">\n    <inertial>\n      <mass value="${arm_mass/4}"/>\n      <origin xyz="0 0 0.125" rpy="0 0 0"/>\n      <inertia ixx="0.005" ixy="0" ixz="0" iyy="0.005" iyz="0" izz="0.0005"/>\n    </inertial>\n    <visual>\n      <origin xyz="0 0 0.125" rpy="0 0 0"/>\n      <geometry>\n        <cylinder radius="0.03" length="0.25"/>\n      </geometry>\n    </visual>\n    <collision>\n      <origin xyz="0 0 0.125" rpy="0 0 0"/>\n      <geometry>\n        <cylinder radius="0.03" length="0.25"/>\n      </geometry>\n    </collision>\n  </link>\n\n  \x3c!-- Left Leg --\x3e\n  <joint name="left_hip_yaw" type="revolute">\n    <parent link="torso"/>\n    <child link="left_thigh_yaw"/>\n    <origin xyz="0.05 -0.05 -0.25" rpy="0 0 0"/>\n    <axis xyz="0 0 1"/>\n    <limit lower="${-M_PI/4}" upper="${M_PI/4}" effort="100" velocity="2"/>\n  </joint>\n\n  <link name="left_thigh_yaw">\n    <inertial>\n      <mass value="${leg_mass/5}"/>\n      <origin xyz="0 0 -0.1" rpy="0 0 0"/>\n      <inertia ixx="0.02" ixy="0" ixz="0" iyy="0.02" iyz="0" izz="0.002"/>\n    </inertial>\n    <visual>\n      <origin xyz="0 0 -0.1" rpy="0 0 0"/>\n      <geometry>\n        <cylinder radius="0.05" length="0.2"/>\n      </geometry>\n    </visual>\n    <collision>\n      <origin xyz="0 0 -0.1" rpy="0 0 0"/>\n      <geometry>\n        <cylinder radius="0.05" length="0.2"/>\n      </geometry>\n    </collision>\n  </link>\n\n  <joint name="left_hip_pitch" type="revolute">\n    <parent link="left_thigh_yaw"/>\n    <child link="left_thigh"/>\n    <origin xyz="0 0 -0.2" rpy="0 0 0"/>\n    <axis xyz="0 1 0"/>\n    <limit lower="${-M_PI/2}" upper="${M_PI/2}" effort="100" velocity="2"/>\n  </joint>\n\n  <link name="left_thigh">\n    <inertial>\n      <mass value="${leg_mass*2/3}"/>\n      <origin xyz="0 0 -0.2" rpy="0 0 0"/>\n      <inertia ixx="0.08" ixy="0" ixz="0" iyy="0.08" iyz="0" izz="0.02"/>\n    </inertial>\n    <visual>\n      <origin xyz="0 0 -0.2" rpy="0 0 0"/>\n      <geometry>\n        <cylinder radius="0.05" length="0.4"/>\n      </geometry>\n    </visual>\n    <collision>\n      <origin xyz="0 0 -0.2" rpy="0 0 0"/>\n      <geometry>\n        <cylinder radius="0.05" length="0.4"/>\n      </geometry>\n    </collision>\n  </link>\n\n  <joint name="left_knee" type="revolute">\n    <parent link="left_thigh"/>\n    <child link="left_shin"/>\n    <origin xyz="0 0 -0.4" rpy="0 0 0"/>\n    <axis xyz="0 1 0"/>\n    <limit lower="0" upper="${M_PI/2}" effort="100" velocity="2"/>\n  </joint>\n\n  <link name="left_shin">\n    <inertial>\n      <mass value="${leg_mass/3}"/>\n      <origin xyz="0 0 -0.2" rpy="0 0 0"/>\n      <inertia ixx="0.04" ixy="0" ixz="0" iyy="0.04" iyz="0" izz="0.01"/>\n    </inertial>\n    <visual>\n      <origin xyz="0 0 -0.2" rpy="0 0 0"/>\n      <geometry>\n        <cylinder radius="0.04" length="0.4"/>\n      </geometry>\n    </visual>\n    <collision>\n      <origin xyz="0 0 -0.2" rpy="0 0 0"/>\n      <geometry>\n        <cylinder radius="0.04" length="0.4"/>\n      </geometry>\n    </collision>\n  </link>\n\n  <joint name="left_ankle" type="revolute">\n    <parent link="left_shin"/>\n    <child link="left_foot"/>\n    <origin xyz="0 0 -0.4" rpy="0 0 0"/>\n    <axis xyz="0 0 1"/>\n    <limit lower="${-M_PI/4}" upper="${M_PI/4}" effort="50" velocity="1"/>\n  </joint>\n\n  <link name="left_foot">\n    <inertial>\n      <mass value="1.0"/>\n      <origin xyz="0.05 0 -0.05" rpy="0 0 0"/>\n      <inertia ixx="0.005" ixy="0" ixz="0" iyy="0.005" iyz="0" izz="0.001"/>\n    </inertial>\n    <visual>\n      <origin xyz="0.05 0 -0.05" rpy="0 0 0"/>\n      <geometry>\n        <box size="0.15 0.08 0.01"/>\n      </geometry>\n    </visual>\n    <collision>\n      <origin xyz="0.05 0 -0.05" rpy="0 0 0"/>\n      <geometry>\n        <box size="0.15 0.08 0.01"/>\n      </geometry>\n    </collision>\n  </link>\n\n  \x3c!-- Right side (mirrored) would follow similar pattern --\x3e\n\n</robot>\n'})}),"\n",(0,r.jsx)(i.h3,{id:"sdf-version-with-gazebo-plugins",children:"SDF Version with Gazebo Plugins"}),"\n",(0,r.jsx)(i.pre,{children:(0,r.jsx)(i.code,{className:"language-xml",children:'<?xml version="1.0"?>\n<sdf version="1.7">\n  <model name="simple_humanoid">\n    \x3c!-- Base footprint --\x3e\n    <link name="base_footprint">\n      <inertial>\n        <mass>0.0001</mass>\n        <inertia>\n          <ixx>0.0001</ixx>\n          <ixy>0</ixy>\n          <ixz>0</ixz>\n          <iyy>0.0001</iyy>\n          <iyz>0</iyz>\n          <izz>0.0001</izz>\n        </inertia>\n      </inertial>\n    </link>\n\n    \x3c!-- Base link --\x3e\n    <link name="base_link">\n      <pose>0 0 0.05 0 0 0</pose>\n      <inertial>\n        <mass>0.5</mass>\n        <inertia>\n          <ixx>0.001</ixx>\n          <ixy>0</ixy>\n          <ixz>0</ixz>\n          <iyy>0.001</iyy>\n          <iyz>0</iyz>\n          <izz>0.001</izz>\n        </inertia>\n      </inertial>\n      <visual name="visual">\n        <geometry>\n          <cylinder>\n            <radius>0.05</radius>\n            <length>0.1</length>\n          </cylinder>\n        </geometry>\n      </visual>\n      <collision name="collision">\n        <geometry>\n          <cylinder>\n            <radius>0.05</radius>\n            <length>0.1</length>\n          </cylinder>\n        </geometry>\n      </collision>\n    </link>\n\n    <joint name="base_joint" type="fixed">\n      <parent>base_footprint</parent>\n      <child>base_link</child>\n    </joint>\n\n    \x3c!-- Torso --\x3e\n    <link name="torso">\n      <pose>0 0 0.2 0 0 0</pose>\n      <inertial>\n        <mass>15.0</mass>\n        <inertia>\n          <ixx>0.8</ixx>\n          <ixy>0</ixy>\n          <ixz>0</ixz>\n          <iyy>0.6</iyy>\n          <iyz>0</iyz>\n          <izz>0.3</izz>\n        </inertia>\n      </inertial>\n      <visual name="visual">\n        <geometry>\n          <box>\n            <size>0.25 0.2 0.5</size>\n          </box>\n        </geometry>\n      </visual>\n      <collision name="collision">\n        <geometry>\n          <box>\n            <size>0.25 0.2 0.5</size>\n          </box>\n        </geometry>\n      </collision>\n    </link>\n\n    <joint name="torso_joint" type="fixed">\n      <parent>base_link</parent>\n      <child>torso</child>\n    </joint>\n\n    \x3c!-- Add Gazebo-specific configurations --\x3e\n    <gazebo reference="torso">\n      <material>Gazebo/Grey</material>\n    </gazebo>\n\n    <gazebo reference="left_foot">\n      <material>Gazebo/Blue</material>\n      <mu1>1.5</mu1>\n      <mu2>1.5</mu2>\n    </gazebo>\n\n    \x3c!-- ROS 2 Control plugin for joint control --\x3e\n    <gazebo>\n      <plugin filename="libgazebo_ros2_control.so" name="gazebo_ros2_control">\n        <parameters>$(find my_robot_gazebo)/config/my_robot_control.yaml</parameters>\n      </plugin>\n    </gazebo>\n  </model>\n</sdf>\n'})}),"\n",(0,r.jsx)(i.h2,{id:"converting-between-urdf-and-sdf",children:"Converting Between URDF and SDF"}),"\n",(0,r.jsx)(i.h3,{id:"using-xacro-to-generate-sdf-from-urdf",children:"Using xacro to Generate SDF from URDF"}),"\n",(0,r.jsx)(i.pre,{children:(0,r.jsx)(i.code,{className:"language-bash",children:"# Convert URDF to SDF using xacro\nxacro robot.urdf.xacro > robot.sdf\n\n# Or directly convert if you have a URDF file\ngz sdf -p robot.urdf > robot.sdf\n"})}),"\n",(0,r.jsx)(i.h3,{id:"ros-2-launch-integration",children:"ROS 2 Launch Integration"}),"\n",(0,r.jsx)(i.pre,{children:(0,r.jsx)(i.code,{className:"language-xml",children:'\x3c!-- In your launch file --\x3e\n<launch>\n  \x3c!-- Convert and spawn URDF robot --\x3e\n  <node name="robot_state_publisher" pkg="robot_state_publisher" exec="robot_state_publisher">\n    <param name="robot_description" value="$(command \'xacro $(find-pkg-share my_robot_description)/urdf/my_robot.urdf.xacro\')"/>\n  </node>\n\n  \x3c!-- Spawn in Gazebo --\x3e\n  <node name="spawn_robot" pkg="gazebo_ros" exec="spawn_entity.py"\n        args="-topic robot_description -entity my_robot -x 0 -y 0 -z 1.0"/>\n</launch>\n'})}),"\n",(0,r.jsx)(i.h2,{id:"optimization-techniques-for-simulation",children:"Optimization Techniques for Simulation"}),"\n",(0,r.jsx)(i.h3,{id:"simplified-collision-models",children:"Simplified Collision Models"}),"\n",(0,r.jsx)(i.p,{children:"For better simulation performance, use simplified collision geometries:"}),"\n",(0,r.jsx)(i.pre,{children:(0,r.jsx)(i.code,{className:"language-xml",children:'\x3c!-- Complex visual model --\x3e\n<visual>\n  <geometry>\n    <mesh filename="package://my_robot/meshes/complex_arm.dae"/>\n  </geometry>\n</visual>\n\n\x3c!-- Simplified collision model --\x3e\n<collision>\n  <geometry>\n    <cylinder>\n      <radius>0.05</radius>\n      <length>0.3</length>\n    </cylinder>\n  </geometry>\n</collision>\n'})}),"\n",(0,r.jsx)(i.h3,{id:"hierarchical-model-organization",children:"Hierarchical Model Organization"}),"\n",(0,r.jsx)(i.p,{children:"Organize complex humanoid models in a logical hierarchy:"}),"\n",(0,r.jsx)(i.pre,{children:(0,r.jsx)(i.code,{children:"base_footprint\n\u251c\u2500\u2500 base_link\n\u2514\u2500\u2500 torso\n    \u251c\u2500\u2500 head\n    \u251c\u2500\u2500 left_arm (chain: shoulder_pitch -> shoulder_roll -> elbow -> wrist)\n    \u251c\u2500\u2500 right_arm (chain: shoulder_pitch -> shoulder_roll -> elbow -> wrist)\n    \u251c\u2500\u2500 left_leg (chain: hip_yaw -> hip_pitch -> knee -> ankle)\n    \u2514\u2500\u2500 right_leg (chain: hip_yaw -> hip_pitch -> knee -> ankle)\n"})}),"\n",(0,r.jsx)(i.h2,{id:"best-practices-for-humanoid-modeling",children:"Best Practices for Humanoid Modeling"}),"\n",(0,r.jsx)(i.h3,{id:"1-realistic-mass-distribution",children:"1. Realistic Mass Distribution"}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsx)(i.li,{children:"Center of mass should be in the torso region"}),"\n",(0,r.jsx)(i.li,{children:"Limbs should have appropriate mass ratios"}),"\n",(0,r.jsx)(i.li,{children:"Use realistic values based on human proportions"}),"\n"]}),"\n",(0,r.jsx)(i.h3,{id:"2-appropriate-joint-limits",children:"2. Appropriate Joint Limits"}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsx)(i.li,{children:"Respect human anatomical limitations"}),"\n",(0,r.jsx)(i.li,{children:"Consider safety margins for control"}),"\n",(0,r.jsx)(i.li,{children:"Account for mechanical constraints"}),"\n"]}),"\n",(0,r.jsx)(i.h3,{id:"3-stable-simulation-parameters",children:"3. Stable Simulation Parameters"}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsx)(i.li,{children:"Proper inertia tensors for stable dynamics"}),"\n",(0,r.jsx)(i.li,{children:"Appropriate friction coefficients for walking"}),"\n",(0,r.jsx)(i.li,{children:"Balanced contact properties"}),"\n"]}),"\n",(0,r.jsx)(i.h3,{id:"4-model-validation",children:"4. Model Validation"}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsx)(i.li,{children:"Check for kinematic loops"}),"\n",(0,r.jsx)(i.li,{children:"Verify mass properties"}),"\n",(0,r.jsx)(i.li,{children:"Test in simulation environment"}),"\n"]}),"\n",(0,r.jsx)(i.h2,{id:"troubleshooting-common-issues",children:"Troubleshooting Common Issues"}),"\n",(0,r.jsx)(i.h3,{id:"robot-falls-through-ground",children:"Robot Falls Through Ground"}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsx)(i.li,{children:"Check that all links have proper collision geometry"}),"\n",(0,r.jsx)(i.li,{children:"Verify mass properties are set (not zero)"}),"\n",(0,r.jsx)(i.li,{children:"Ensure inertial properties are properly defined"}),"\n"]}),"\n",(0,r.jsx)(i.h3,{id:"unstable-joint-behavior",children:"Unstable Joint Behavior"}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsx)(i.li,{children:"Verify joint limits and dynamics parameters"}),"\n",(0,r.jsx)(i.li,{children:"Check for proper parent-child relationships"}),"\n",(0,r.jsx)(i.li,{children:"Adjust solver parameters in Gazebo"}),"\n"]}),"\n",(0,r.jsx)(i.h3,{id:"performance-issues",children:"Performance Issues"}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsx)(i.li,{children:"Simplify collision geometry"}),"\n",(0,r.jsx)(i.li,{children:"Reduce model complexity where possible"}),"\n",(0,r.jsx)(i.li,{children:"Use appropriate physics parameters"}),"\n"]}),"\n",(0,r.jsx)(i.h2,{id:"summary",children:"Summary"}),"\n",(0,r.jsx)(i.p,{children:"This chapter covered the essential aspects of robot description formats for humanoid simulation:"}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsx)(i.li,{children:"URDF vs SDF differences and use cases"}),"\n",(0,r.jsx)(i.li,{children:"Creating complex humanoid models with proper kinematic structure"}),"\n",(0,r.jsx)(i.li,{children:"Simulation-specific extensions in SDF"}),"\n",(0,r.jsx)(i.li,{children:"Optimization techniques for better performance"}),"\n",(0,r.jsx)(i.li,{children:"Best practices for stable and realistic simulation"}),"\n"]}),"\n",(0,r.jsx)(i.p,{children:"Understanding both URDF and SDF formats is crucial for developing humanoid robots that can be effectively simulated in Gazebo and controlled through ROS 2. The combination of accurate kinematic modeling with proper simulation parameters ensures realistic behavior in virtual environments."})]})}function m(n={}){const{wrapper:i}={...(0,l.R)(),...n.components};return i?(0,r.jsx)(i,{...n,children:(0,r.jsx)(c,{...n})}):c(n)}},8453(n,i,e){e.d(i,{R:()=>t,x:()=>a});var o=e(6540);const r={},l=o.createContext(r);function t(n){const i=o.useContext(l);return o.useMemo(function(){return"function"==typeof n?n(i):{...i,...n}},[i,n])}function a(n){let i;return i=n.disableParentContext?"function"==typeof n.components?n.components(r):n.components||r:t(n.components),o.createElement(l.Provider,{value:i},n.children)}}}]);